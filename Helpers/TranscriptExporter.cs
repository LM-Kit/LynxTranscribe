using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Packaging;
using LMKit.Speech;
using System.Text;
using Wp = DocumentFormat.OpenXml.Wordprocessing;

namespace LynxTranscribe.Helpers;

/// <summary>
/// Static class for exporting transcripts to various file formats.
/// </summary>
public static class TranscriptExporter
{
    /// <summary>
    /// Creates a Word document (.docx) from transcript content.
    /// </summary>
    /// <param name="filePath">Output file path</param>
    /// <param name="content">Transcript text content</param>
    /// <param name="sourceFileName">Original audio file name for metadata</param>
    public static void ExportToDocx(string filePath, string content, string? sourceFileName = null)
    {
        using var document = WordprocessingDocument.Create(filePath, WordprocessingDocumentType.Document);

        // Add main document part
        var mainPart = document.AddMainDocumentPart();
        mainPart.Document = new Wp.Document();
        var body = mainPart.Document.AppendChild(new Wp.Body());

        // Add title
        var titlePara = body.AppendChild(new Wp.Paragraph());
        var titleRun = titlePara.AppendChild(new Wp.Run());
        titleRun.AppendChild(new Wp.RunProperties(
            new Wp.Bold(),
            new Wp.FontSize { Val = "36" }, // 18pt (half-points)
            new Wp.RunFonts { Ascii = "Arial", HighAnsi = "Arial" }
        ));
        titleRun.AppendChild(new Wp.Text("Transcript"));

        // Add metadata line
        var displaySourceName = sourceFileName ?? "Unknown";
        var metaPara = body.AppendChild(new Wp.Paragraph());
        var metaRun = metaPara.AppendChild(new Wp.Run());
        metaRun.AppendChild(new Wp.RunProperties(
            new Wp.FontSize { Val = "20" }, // 10pt
            new Wp.Color { Val = "666666" },
            new Wp.RunFonts { Ascii = "Arial", HighAnsi = "Arial" }
        ));
        metaRun.AppendChild(new Wp.Text($"Source: {displaySourceName}  |  Generated: {DateTime.Now:yyyy-MM-dd HH:mm}"));

        // Add spacing paragraph
        body.AppendChild(new Wp.Paragraph());

        // Add content paragraphs
        var lines = content.Split(new[] { Environment.NewLine, "\n" }, StringSplitOptions.None);
        foreach (var line in lines)
        {
            var para = body.AppendChild(new Wp.Paragraph());

            // Add paragraph properties for line spacing
            para.AppendChild(new Wp.ParagraphProperties(
                new Wp.SpacingBetweenLines { After = "120", Line = "276", LineRule = Wp.LineSpacingRuleValues.Auto }
            ));

            var run = para.AppendChild(new Wp.Run());
            run.AppendChild(new Wp.RunProperties(
                new Wp.FontSize { Val = "24" }, // 12pt
                new Wp.RunFonts { Ascii = "Arial", HighAnsi = "Arial" }
            ));
            run.AppendChild(new Wp.Text(line) { Space = SpaceProcessingModeValues.Preserve });
        }

        // Add footer spacing
        body.AppendChild(new Wp.Paragraph());

        // Add branding footer
        var footerPara = body.AppendChild(new Wp.Paragraph());
        var footerRun = footerPara.AppendChild(new Wp.Run());
        footerRun.AppendChild(new Wp.RunProperties(
            new Wp.FontSize { Val = "18" }, // 9pt
            new Wp.Color { Val = "999999" },
            new Wp.RunFonts { Ascii = "Arial", HighAnsi = "Arial" }
        ));
        footerRun.AppendChild(new Wp.Text($"Generated by {AppConstants.AppName} v{AppConstants.Version} - Powered by LM-Kit Technology"));

        document.Save();
    }

    /// <summary>
    /// Creates RTF content from transcript text.
    /// </summary>
    /// <param name="content">Transcript text content</param>
    /// <param name="sourceFileName">Original audio file name for metadata</param>
    /// <returns>RTF formatted string</returns>
    public static string CreateRtfContent(string content, string? sourceFileName = null)
    {
        var sb = new StringBuilder();

        // RTF header with font table and color table
        sb.AppendLine(@"{\rtf1\ansi\ansicpg1252\deff0");
        sb.AppendLine(@"{\fonttbl{\f0\fswiss\fcharset0 Arial;}}");
        sb.AppendLine(@"{\colortbl;\red102\green102\blue102;\red153\green153\blue153;}");

        // Title - bold, 18pt
        sb.AppendLine(@"\f0\fs36\b Transcript\b0\par");

        // Metadata - 10pt, gray
        var displaySourceName = sourceFileName ?? "Unknown";
        sb.AppendLine($@"\fs20\cf1 Source: {EscapeRtf(displaySourceName)}  |  Generated: {DateTime.Now:yyyy-MM-dd HH:mm}\cf0\par");

        // Spacing
        sb.AppendLine(@"\par");

        // Content - 12pt
        sb.AppendLine(@"\fs24");
        var lines = content.Split(new[] { Environment.NewLine, "\n" }, StringSplitOptions.None);
        foreach (var line in lines)
        {
            sb.AppendLine($@"{EscapeRtf(line)}\par");
        }

        // Footer spacing
        sb.AppendLine(@"\par");

        // Branding footer - 9pt, light gray
        sb.AppendLine($@"\fs18\cf2 Generated by {AppConstants.AppName} v{AppConstants.Version} - Powered by LM-Kit Technology\cf0\par");

        // Close RTF
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Creates plain text content with metadata header.
    /// </summary>
    /// <param name="content">Transcript text content</param>
    /// <param name="sourceFileName">Original audio file name for metadata</param>
    /// <param name="includeMetadata">Whether to include metadata header</param>
    /// <returns>Plain text string</returns>
    public static string CreateTxtContent(string content, string? sourceFileName = null, bool includeMetadata = false)
    {
        if (!includeMetadata)
        {
            return content;
        }

        var sb = new StringBuilder();
        sb.AppendLine("TRANSCRIPT");
        sb.AppendLine(new string('-', 40));
        sb.AppendLine($"Source: {sourceFileName ?? "Unknown"}");
        sb.AppendLine($"Generated: {DateTime.Now:yyyy-MM-dd HH:mm}");
        sb.AppendLine(new string('-', 40));
        sb.AppendLine();
        sb.Append(content);

        return sb.ToString();
    }

    /// <summary>
    /// Gets a unique file path by appending a counter if the file already exists.
    /// </summary>
    /// <param name="fileName">Desired file name with extension</param>
    /// <param name="directory">Target directory (defaults to Documents folder)</param>
    /// <returns>Unique file path</returns>
    public static string GetUniqueFilePath(string fileName, string? directory = null)
    {
        var targetDirectory = directory ?? Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
        var filePath = Path.Combine(targetDirectory, fileName);

        if (!File.Exists(filePath))
        {
            return filePath;
        }

        var nameWithoutExt = Path.GetFileNameWithoutExtension(fileName);
        var ext = Path.GetExtension(fileName);
        var counter = 1;

        while (File.Exists(filePath))
        {
            filePath = Path.Combine(targetDirectory, $"{nameWithoutExt}_{counter++}{ext}");
        }

        return filePath;
    }

    /// <summary>
    /// Creates SRT subtitle content from timestamped segments.
    /// </summary>
    /// <param name="segments">List of timestamped segments</param>
    /// <returns>SRT formatted string</returns>
    public static string CreateSrtContent(List<AudioSegment> segments)
    {
        var sb = new StringBuilder();

        for (int i = 0; i < segments.Count; i++)
        {
            var segment = segments[i];
            sb.AppendLine((i + 1).ToString());
            sb.AppendLine($"{FormatSrtTime(segment.Start)} --> {FormatSrtTime(segment.End)}");
            sb.AppendLine(segment.Text.Trim());
            sb.AppendLine();
        }

        return sb.ToString();
    }

    /// <summary>
    /// Creates VTT (WebVTT) subtitle content from timestamped segments.
    /// </summary>
    /// <param name="segments">List of timestamped segments</param>
    /// <returns>VTT formatted string</returns>
    public static string CreateVttContent(List<AudioSegment> segments)
    {
        var sb = new StringBuilder();

        // VTT header
        sb.AppendLine("WEBVTT");
        sb.AppendLine();

        for (int i = 0; i < segments.Count; i++)
        {
            var segment = segments[i];
            sb.AppendLine((i + 1).ToString());
            sb.AppendLine($"{FormatVttTime(segment.Start)} --> {FormatVttTime(segment.End)}");
            sb.AppendLine(segment.Text.Trim());
            sb.AppendLine();
        }

        return sb.ToString();
    }

    /// <summary>
    /// Creates transcript text with timestamps.
    /// </summary>
    /// <param name="segments">List of timestamped segments</param>
    /// <returns>Text with timestamps</returns>
    public static string CreateTimestampedText(List<AudioSegment> segments)
    {
        var sb = new StringBuilder();

        foreach (var segment in segments)
        {
            var timestamp = $"[{FormatDisplayTime(segment.Start)}]";
            sb.AppendLine($"{timestamp} {segment.Text.Trim()}");
        }

        return sb.ToString();
    }

    /// <summary>
    /// Formats a TimeSpan for SRT (HH:MM:SS,mmm with comma).
    /// </summary>
    private static string FormatSrtTime(TimeSpan time)
    {
        return $"{(int)time.TotalHours:00}:{time.Minutes:00}:{time.Seconds:00},{time.Milliseconds:000}";
    }

    /// <summary>
    /// Formats a TimeSpan for VTT (HH:MM:SS.mmm with period).
    /// </summary>
    private static string FormatVttTime(TimeSpan time)
    {
        return $"{(int)time.TotalHours:00}:{time.Minutes:00}:{time.Seconds:00}.{time.Milliseconds:000}";
    }

    /// <summary>
    /// Formats a TimeSpan for display (MM:SS or HH:MM:SS).
    /// </summary>
    public static string FormatDisplayTime(TimeSpan time)
    {
        if (time.TotalHours >= 1)
        {
            return $"{(int)time.TotalHours}:{time.Minutes:00}:{time.Seconds:00}";
        }

        return $"{time.Minutes}:{time.Seconds:00}";
    }

    private static string EscapeRtf(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return string.Empty;
        }

        var sb = new StringBuilder();
        foreach (var c in text)
        {
            if (c == '\\')
            {
                sb.Append(@"\\");
            }
            else if (c == '{')
            {
                sb.Append(@"\{");
            }
            else if (c == '}')
            {
                sb.Append(@"\}");
            }
            else if (c > 127)
            {
                sb.Append($@"\u{(int)c}?");
            }
            else
            {
                sb.Append(c);
            }
        }
        return sb.ToString();
    }
}
